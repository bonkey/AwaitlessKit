# RFC SR-06: groue/Semaphore vs DispatchSemaphore Analysis

**Status**: Draft  
**Author**: Generated by Copilot  
**Date**: 2025-01-06  

## Summary

This RFC analyzes whether AwaitlessKit should replace `DispatchSemaphore` with `groue/Semaphore`'s `AsyncSemaphore` in the `Awaitless.run` functions. The analysis evaluates thread-blocking behavior, Swift Concurrency integration, performance implications, and platform compatibility to provide a data-driven recommendation.

## Problem Statement

AwaitlessKit's core `Awaitless.run` functions currently use `DispatchSemaphore` to synchronize between async and sync contexts. This implementation has the following characteristics:

```swift
public static func run(_ code: sending () async throws(Failure) -> Success) throws(Failure) -> Success {
    let semaphore = DispatchSemaphore(value: 0)
    nonisolated(unsafe) var result: Result<Success, Failure>? = nil

    withoutActuallyEscaping(code) {
        nonisolated(unsafe) let sendableCode = $0

        let coreTask = Task<Void, Never>.detached(priority: .userInitiated) { @Sendable () async in
            do {
                result = try await .success(sendableCode())
            } catch {
                result = .failure(error as! Failure)
            }
        }

        Task<Void, Never>.detached(priority: .userInitiated) {
            await coreTask.value
            semaphore.signal()
        }

        semaphore.wait()  // BLOCKS THE CALLING THREAD
    }

    return try result!.get()
}
```

**Current Issues with DispatchSemaphore:**

1. **Thread Blocking**: `semaphore.wait()` blocks the calling thread until the async operation completes
2. **Swift Concurrency Mismatch**: Uses Grand Central Dispatch (GCD) primitives instead of Swift Concurrency primitives
3. **Potential Deadlocks**: Can cause deadlocks if called from a Swift Concurrency context bound to the same thread
4. **Resource Utilization**: Blocked threads consume system resources unnecessarily

**Impact Assessment:**

- **Performance Impact**: Thread blocking can lead to thread pool exhaustion in high-concurrency scenarios
- **Modern Swift Integration**: DispatchSemaphore predates Swift Concurrency and doesn't align with modern patterns
- **Developer Experience**: Requires careful documentation about deadlock risks

## Solution Overview

The `groue/Semaphore` library provides `AsyncSemaphore`, which offers the same synchronization semantics but without thread blocking:

```swift
// Hypothetical AwaitlessKit implementation with AsyncSemaphore
public static func run(_ code: sending () async throws(Failure) -> Success) throws(Failure) -> Success {
    let semaphore = AsyncSemaphore(value: 0)
    nonisolated(unsafe) var result: Result<Success, Failure>? = nil

    // Create async context to use AsyncSemaphore.wait()
    let asyncResult = Task<Success, Failure> {
        withoutActuallyEscaping(code) {
            nonisolated(unsafe) let sendableCode = $0

            let coreTask = Task<Void, Never>.detached(priority: .userInitiated) { @Sendable () async in
                do {
                    result = try await .success(sendableCode())
                } catch {
                    result = .failure(error as! Failure)
                }
                semaphore.signal()
            }

            await semaphore.wait()  // SUSPENDS TASK, DOESN'T BLOCK THREAD
            return try result!.get()
        }
    }
    
    // But we still need to bridge to sync context...
    // This approach has fundamental limitations
}
```

**Key Benefits:**
- No thread blocking - tasks are suspended instead
- Better Swift Concurrency integration
- Reduced risk of thread pool exhaustion
- More modern architecture alignment

## Approaches Evaluated

### Approach 1: Direct Replacement with AsyncSemaphore

**Design:**
Replace `DispatchSemaphore` with `AsyncSemaphore` in existing `Awaitless.run` functions.

**Implementation Strategy:**
```swift
import Semaphore

extension Awaitless {
    public static func run(_ code: sending () async throws(Failure) -> Success) throws(Failure) -> Success {
        // Challenge: AsyncSemaphore.wait() is async, but we need sync return
        // Would require nested RunLoop or similar sync-async bridge
        fatalError("Implementation challenge - see technical analysis")
    }
}
```

**Pros:**
- Eliminates thread blocking behavior
- Better Swift Concurrency alignment
- Reduced deadlock risk in some scenarios

**Cons:**
- **FUNDAMENTAL PROBLEM**: `AsyncSemaphore.wait()` is async, but `Awaitless.run` must return synchronously
- Would still require a sync-async bridge (potentially using `RunLoop` or blocking mechanisms)
- Adds external dependency to the package
- Increases complexity without solving the core sync-async bridge problem

**Technical Feasibility**: **LOW** - The fundamental requirement to bridge from sync to async context means we still need some form of blocking mechanism.

### Approach 2: Hybrid Approach with Platform-Specific Implementation

**Design:**
Use `AsyncSemaphore` on platforms where it provides benefits, fallback to `DispatchSemaphore` elsewhere.

**Implementation Strategy:**
```swift
#if canImport(Semaphore) && !os(Linux)
    // Use AsyncSemaphore with RunLoop-based sync bridge
    let semaphore = AsyncSemaphore(value: 0)
    // Complex implementation required
#else
    // Current DispatchSemaphore implementation
    let semaphore = DispatchSemaphore(value: 0)
    // Existing proven implementation
#endif
```

**Pros:**
- Potential benefits on supported platforms
- Maintains compatibility with existing behavior
- Gradual migration path

**Cons:**
- Significantly increased complexity
- Platform-specific behavior differences
- Still requires solving the sync-async bridge problem
- Testing complexity increases exponentially
- Maintenance burden of two implementations

**Technical Feasibility**: **MEDIUM** - Possible but very complex, with questionable benefits.

### Approach 3: Alternative Sync-Async Bridge Mechanisms

**Design:**
Investigate other mechanisms for sync-async bridging that don't use semaphores at all.

**Options Evaluated:**
1. **RunLoop-based approach**: Use `CFRunLoop` to pump events while waiting
2. **Continuation-based approach**: Use `withUnsafeContinuation` patterns
3. **Task blocking approach**: Block on `Task.value` directly

**Implementation Example (RunLoop-based):**
```swift
public static func run(_ code: sending () async throws(Failure) -> Success) throws(Failure) -> Success {
    nonisolated(unsafe) var result: Result<Success, Failure>? = nil
    nonisolated(unsafe) var completed = false

    let task = Task<Void, Never>.detached(priority: .userInitiated) { @Sendable () async in
        do {
            result = try await .success(code())
        } catch {
            result = .failure(error as! Failure)
        }
        completed = true
        CFRunLoopStop(CFRunLoopGetCurrent())
    }

    while !completed {
        CFRunLoopRunInMode(.defaultMode, 0.1, true)
    }

    return try result!.get()
}
```

**Pros:**
- No external dependencies
- Potentially better Swift Concurrency integration
- No semaphore usage at all

**Cons:**
- Platform-specific implementation required (CFRunLoop not available everywhere)
- Complex edge case handling
- Unfamiliar pattern for most developers
- Potential performance implications

**Technical Feasibility**: **MEDIUM** - Possible but introduces new complexity and platform dependencies.

### Approach 4: Status Quo with Enhanced Documentation

**Design:**
Keep current `DispatchSemaphore` implementation but improve documentation and add safety measures.

**Implementation Strategy:**
```swift
extension Awaitless {
    /// Executes an async closure synchronously.
    /// 
    /// ⚠️ **Thread Safety Warning**: This function blocks the calling thread.
    /// Do not call from Swift Concurrency contexts (actors, @MainActor, etc.)
    /// that might be bound to the same thread as the async operation.
    ///
    /// ⚠️ **Performance Warning**: In high-concurrency scenarios, consider
    /// using async/await directly instead of bridging to synchronous code.
    @available(*, noasync, message: "Consider using async/await instead of bridging to sync")
    public static func run(_ code: sending () async throws(Failure) -> Success) throws(Failure) -> Success {
        // Add runtime detection of problematic contexts where possible
        if Thread.isMainThread {
            print("Warning: Awaitless.run called from main thread. Consider async alternatives.")
        }
        
        // Current proven implementation
        let semaphore = DispatchSemaphore(value: 0)
        // ... rest of existing implementation
    }
}
```

**Pros:**
- **Zero implementation risk** - current code is proven and reliable
- No new dependencies or complexity
- Maintains compatibility with all existing code
- Clear documentation about limitations and best practices
- Runtime warnings for problematic usage patterns

**Cons:**
- Doesn't solve underlying thread-blocking issue
- Still uses older GCD primitives instead of Swift Concurrency
- Potential for deadlocks in specific scenarios remains

**Technical Feasibility**: **HIGH** - Simple documentation and warning improvements.

## Recommended Solution

**Recommendation: Approach 4 - Status Quo with Enhanced Documentation**

After thorough technical analysis, I recommend **keeping the current DispatchSemaphore implementation** while enhancing documentation and adding developer guidance.

### Rationale

1. **Fundamental Technical Constraint**: The core requirement of `Awaitless.run` is to bridge from synchronous to asynchronous contexts. This inherently requires some form of blocking or busy-waiting mechanism. `AsyncSemaphore` doesn't eliminate this constraint - it only moves the blocking to a different layer.

2. **Implementation Reality**: Using `AsyncSemaphore` would still require a sync-async bridge mechanism (like `RunLoop`, continuation blocking, or similar), which defeats the primary benefit of avoiding thread blocking.

3. **Proven Reliability**: The current `DispatchSemaphore` implementation has been thoroughly tested and proven reliable across all platforms (Linux, macOS, iOS, etc.).

4. **Complexity vs Benefit**: Alternative approaches introduce significant complexity for minimal or no practical benefit.

5. **Platform Compatibility**: `DispatchSemaphore` works consistently across all platforms, while `groue/Semaphore` has platform restrictions.

### Technical Justification

The fundamental issue is that `Awaitless.run` serves a specific architectural purpose: enabling legacy synchronous code to call modern async functions. This is inherently a "bridge" scenario that requires blocking behavior at some level.

**Why AsyncSemaphore Doesn't Solve the Core Problem:**

```swift
// Current DispatchSemaphore approach:
semaphore.wait() // Blocks thread - clearly understood behavior

// Hypothetical AsyncSemaphore approach would still need:
RunLoop.run() // Still blocks thread, but with more complexity
// OR
Task.value.wait() // Still blocks thread, different mechanism
// OR
continuation.wait() // Still blocks thread, continuation-based
```

All approaches to sync-async bridging ultimately require blocking the calling thread or busy-waiting. `AsyncSemaphore` is designed for async contexts, not sync-async bridging.

## Implementation Strategy

### Phase 1: Enhanced Documentation and Warnings (Immediate)

1. **Improve Function Documentation:**
   - Add clear warnings about thread blocking behavior
   - Document deadlock scenarios and how to avoid them
   - Provide examples of proper usage patterns
   - Explain when to use async/await instead

2. **Add Runtime Safety Checks:**
   ```swift
   @available(*, noasync, message: "Consider using async/await instead")
   public static func run(_ code: sending () async throws(Failure) -> Success) throws(Failure) -> Success {
       // Optional runtime warnings for problematic contexts
       #if DEBUG
       if Thread.isMainThread && ProcessInfo.processInfo.environment["AWAITLESS_SUPPRESS_WARNINGS"] == nil {
           print("⚠️ Awaitless.run called from main thread. Consider async alternatives.")
       }
       #endif
       
       // Current implementation
   }
   ```

3. **Update README and Documentation:**
   - Add section on performance considerations
   - Document best practices for sync-async bridging
   - Provide migration guides for moving to full async/await

### Phase 2: Future Monitoring (6-12 months)

1. **Monitor Community Feedback**: Track issues related to thread blocking or deadlocks
2. **Evaluate New Swift Concurrency Features**: Watch for new Swift language features that might enable better sync-async bridging
3. **Performance Benchmarking**: Create benchmarks to measure real-world impact of current approach

## Comparison Matrix

| Criteria | DispatchSemaphore (Current) | AsyncSemaphore | RunLoop Bridge | Hybrid Approach |
|----------|----------------------------|----------------|----------------|-----------------|
| **Thread Blocking** | ❌ Blocks thread | ⚠️ Still needs blocking layer | ❌ Blocks thread | ❌ Blocks thread |
| **Implementation Complexity** | ✅ Simple | ❌ Complex | ❌ Very complex | ❌ Extremely complex |
| **Platform Support** | ✅ All platforms | ⚠️ Limited platforms | ❌ Platform-specific | ❌ Platform-specific |
| **External Dependencies** | ✅ None | ❌ groue/Semaphore | ✅ None | ❌ groue/Semaphore |
| **Swift Concurrency Alignment** | ⚠️ GCD-based | ✅ Async-based | ⚠️ CFRunLoop-based | ⚠️ Mixed |
| **Deadlock Risk** | ⚠️ Known patterns | ⚠️ Different patterns | ❌ New unknown patterns | ❌ Multiple patterns |
| **Testing Complexity** | ✅ Simple | ❌ Complex | ❌ Very complex | ❌ Extremely complex |
| **Performance** | ✅ Predictable | ❓ Unknown overhead | ❓ RunLoop overhead | ❓ Multiple overheads |
| **Maintenance Burden** | ✅ Low | ❌ Medium | ❌ High | ❌ Very high |
| **Migration Risk** | ✅ None | ❌ High | ❌ Very high | ❌ Extremely high |

**Winner: DispatchSemaphore (Current Implementation)**

## Decision and Next Steps

### Formal Decision

**We will maintain the current DispatchSemaphore implementation** in AwaitlessKit for the following reasons:

1. **Technical**: No alternative approach eliminates the fundamental need for thread blocking in sync-async bridges
2. **Reliability**: Current implementation is proven and works across all platforms
3. **Simplicity**: Minimal complexity and maintenance burden
4. **Risk**: Zero implementation risk vs. high risk of introducing new issues

### Immediate Action Items

1. **Enhanced Documentation** (Complete within 1 week):
   - Update function documentation with clear warnings and best practices
   - Add performance considerations to README
   - Create usage examples showing proper patterns

2. **Developer Experience Improvements** (Complete within 2 weeks):
   - Add optional runtime warnings for potentially problematic usage
   - Improve error messages and debugging information
   - Add compiler attributes to guide proper usage

3. **Testing and Validation** (Complete within 1 week):
   - Ensure existing tests cover edge cases and potential deadlock scenarios
   - Add performance benchmarks to establish baseline metrics
   - Validate behavior across all supported platforms

### Future Considerations

- **Monitor Swift Evolution**: Watch for new language features that might enable better sync-async bridging
- **Community Feedback**: Track user reports of issues or feature requests related to the current implementation
- **Performance Analysis**: Periodically benchmark the current approach against alternatives as they mature

### Success Criteria

This decision will be considered successful if:

1. **Zero Breaking Changes**: No existing AwaitlessKit users are impacted
2. **Improved Documentation**: Developers have clear guidance on proper usage patterns
3. **Maintained Reliability**: Current test suite continues to pass with 100% success rate
4. **Enhanced Developer Experience**: Better warnings and error messages reduce support burden

## Conclusion

While `groue/Semaphore` is an excellent library for async-to-async synchronization, it does not provide meaningful benefits for AwaitlessKit's specific use case of sync-to-async bridging. The current `DispatchSemaphore` implementation is the right tool for this architectural requirement.

The focus should be on improving documentation, adding safety measures, and guiding developers toward modern async/await patterns when appropriate, rather than introducing complexity that doesn't solve the fundamental constraints of sync-async bridging.