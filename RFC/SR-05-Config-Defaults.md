# RFC SR-05: Configuration Defaults

**Status**: Draft  
**Author**: Generated by Copilot  
**Date**: 2025-01-03  

## Summary

Design an opt-in configuration mechanism for AwaitlessKit defaults (e.g., prefix, default output type, delivery) to enable teams to set consistent defaults at type or file scope without repeating attributes everywhere.

## Motivation

Currently, AwaitlessKit macros require explicit specification of common parameters on every usage:

```swift
class DataService {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func streamData() async throws -> [Data] { ... }
    
    @AwaitlessCompletion(prefix: "sync", .deprecated("Use async version"))
    func processData() async throws -> Result { ... }
}
```

This leads to repetitive code and inconsistent configurations across teams. A configuration mechanism would allow teams to establish consistent defaults while maintaining override capabilities.

## Design Approaches

### Approach 1: Type-Scoped Configuration

#### Design

A new `@AwaitlessConfig` attribute that can be applied to types (classes, structs, actors) to establish defaults for all contained async methods.

```swift
@AwaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)
class DataService {
    @Awaitless  // Uses defaults: prefix="sync", availability=.deprecated
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses defaults: prefix="sync", delivery=.main, availability=.deprecated
    func streamData() async throws -> [Data] { ... }
    
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other defaults
    func oldMethod() async throws -> String { ... }
}
```

#### API Surface

```swift
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **Type-level @AwaitlessConfig** provides defaults for the type
3. **Built-in defaults** are used when neither method nor type specifies a value

#### Macro Implementation Challenges

**Pros:**
- Natural scoping model aligns with Swift's type system
- Clear ownership and visibility of configuration
- Can be discovered through macro context's parent declarations

**Cons:**
- **Macro Discovery Complexity**: Attached macros need to traverse up the syntax tree to find `@AwaitlessConfig` on the containing type
- **Multiple Inheritance**: If a type has nested types, precedence becomes complex
- **Performance**: Each macro invocation requires AST traversal to find configuration

### Approach 2: File-Scoped Configuration

#### Design

A file-scoped freestanding macro `#awaitlessConfig` that establishes defaults for all AwaitlessKit macros in the same file.

```swift
#awaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"), 
    delivery: .main
)

class DataService {
    @Awaitless  // Uses file defaults
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses file defaults
    func streamData() async throws -> [Data] { ... }
}

class NetworkService {
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other file defaults
    func request() async throws -> Response { ... }
}
```

#### API Surface

```swift
@freestanding(declaration)
public macro awaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **File-level #awaitlessConfig** provides defaults for the entire file  
3. **Built-in defaults** are used when neither method nor file specifies a value

#### Macro Implementation Challenges

**Pros:**
- **Simpler Discovery**: File-scoped configuration can be found by scanning source file
- **Clear Boundaries**: One configuration per file, no inheritance complexity
- **Performance**: Configuration lookup is straightforward

**Cons:**
- **Non-Swift-like**: File-scoped directives are uncommon in Swift
- **Global State**: Configuration affects entire file, which may be surprising
- **Limited Granularity**: Cannot have different defaults for different types in same file

## Feasibility Analysis

### Macro Context Limitations

Swift macros have limited ability to access information outside their immediate context:

1. **No Global State**: Macros cannot share state between invocations
2. **Limited AST Access**: Cannot easily traverse to sibling or parent declarations
3. **Expansion Order**: No guarantee about the order of macro expansion

### Technical Approach Options

#### Option A: Syntax Tree Traversal (Type-scoped)

```swift
// In AwaitlessSyncMacro
public static func expansion(
    of node: AttributeSyntax,
    providingPeersOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
) throws -> [DeclSyntax] {
    // Look for @AwaitlessConfig on containing type
    let containingType = findContainingType(declaration, in: context)
    let config = extractConfig(from: containingType)
    // Merge with explicit parameters...
}
```

**Challenges**: Requires complex AST traversal, may not work reliably across different syntax contexts.

#### Option B: Generated Configuration Storage (Type-scoped)

```swift
@AwaitlessConfig(prefix: "sync")
class DataService {
    // Generated by @AwaitlessConfig:
    static let __awaitlessConfig = AwaitlessConfigData(prefix: "sync", ...)
    
    @Awaitless  // Can access DataService.__awaitlessConfig
    func fetchUser() async throws -> User { ... }
}
```

**Challenges**: Requires coordination between `@AwaitlessConfig` and other macros.

#### Option C: Source Text Analysis (File-scoped)

```swift
// In any AwaitlessKit macro
public static func expansion(
    of node: AttributeSyntax,
    providingPeersOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
) throws -> [DeclSyntax] {
    // Parse source file text for #awaitlessConfig
    let config = parseConfigFromSource(context.sourceFile)
    // Merge with explicit parameters...
}
```

**Challenges**: Fragile text parsing, source file access limitations.

### Approach 3: Instance-Based Configuration

#### Design

A global or module-scoped configuration instance that provides defaults for all AwaitlessKit macros. Configuration can be set through a singleton or multiple instances per module.

```swift
// Global singleton approach
AwaitlessConfig.shared.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)

class DataService {
    @Awaitless  // Uses AwaitlessConfig.shared defaults
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses AwaitlessConfig.shared defaults
    func streamData() async throws -> [Data] { ... }
    
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other global defaults
    func oldMethod() async throws -> String { ... }
}
```

Alternative module-scoped approach:
```swift
// Per-module configuration
extension AwaitlessConfig {
    static let dataModule = AwaitlessConfig(
        prefix: "sync",
        availability: .deprecated("Use async version")
    )
}

// Set as current for this module/file
AwaitlessConfig.setCurrent(.dataModule)

class DataService {
    @Awaitless  // Uses AwaitlessConfig.dataModule defaults
    func fetchUser(id: String) async throws -> User { ... }
}
```

#### API Surface

```swift
public class AwaitlessConfig {
    public static let shared = AwaitlessConfig()
    public private(set) static var current: AwaitlessConfig = shared
    
    public var prefix: String?
    public var availability: AwaitlessAvailability?
    public var delivery: AwaitlessDelivery?
    public var strategy: AwaitlessSynchronizationStrategy?
    
    public init(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
    
    public func setDefaults(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
    
    public static func setCurrent(_ config: AwaitlessConfig)
    public static func withConfig<T>(_ config: AwaitlessConfig, _ block: () throws -> T) rethrows -> T
}
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **Type-level @AwaitlessConfig** (if present) overrides instance defaults
3. **Instance configuration** (`AwaitlessConfig.current`) provides base defaults
4. **Built-in defaults** are used when no configuration specifies a value

#### Macro Implementation Challenges

**Pros:**
- **Simplest Integration**: Macros can directly access global state for defaults
- **Runtime Flexibility**: Configuration can be changed at runtime
- **Module Scoping**: Can support different configs per module via `setCurrent()`
- **No AST Traversal**: No complex syntax tree navigation required
- **Familiar Pattern**: Similar to other Swift configuration systems

**Cons:**
- **Global State**: Introduces shared mutable state, potential for unexpected behavior
- **Macro Limitations**: Swift macros have limited access to runtime state during compilation
- **Thread Safety**: Requires careful synchronization in multi-threaded environments
- **Testing Complexity**: Global state can make tests harder to isolate
- **Compile-Time Only**: Configuration must be deterministic at macro expansion time

#### Technical Feasibility Concerns

**Critical Challenge**: Swift macros execute during compilation, not runtime. They cannot access mutable global state that changes during program execution. Any instance-based approach would need to:

1. **Compile-Time Configuration**: The configuration must be statically determinable at macro expansion time
2. **Source Generation**: Use compile-time constants or generate configuration code
3. **Build System Integration**: Potentially require build-time configuration injection

**Possible Implementation Strategies:**

**Strategy A: Compile-Time Constants**
```swift
// Must be compile-time constant
public enum AwaitlessConfig {
    public static let prefix: String = "sync"  // Set at compile time
    public static let availability: AwaitlessAvailability = .deprecated("Use async version")
}
```

**Strategy B: Build Configuration**
```swift
// Generated during build from external config
// awaitless.config.swift (generated)
extension AwaitlessConfig {
    static let buildTimeDefaults = AwaitlessConfigData(
        prefix: "sync",
        availability: .deprecated("Use async version")
    )
}
```

**Strategy C: Module-Level Constants**
```swift
// Each module defines its own constants
public enum DataServiceConfig {
    public static let awaitlessPrefix = "sync"
    public static let awaitlessAvailability = AwaitlessAvailability.deprecated("Use async version")
}

// Macros use these constants as defaults
@Awaitless  // Automatically uses DataServiceConfig values if available
func fetchUser() async throws -> User { ... }
```

## Comparison Matrix

| Aspect | Type-Scoped (@AwaitlessConfig) | File-Scoped (#awaitlessConfig) | Instance-Based (AwaitlessConfig) |
|--------|-------------------------------|--------------------------------|----------------------------------|
| **Swift Idioms** | ✅ Natural type-based scoping | ❌ Unusual file-level directive | ✅ Familiar singleton pattern |
| **Implementation** | ❌ Complex AST traversal | ⚠️ Source text parsing | ❌ Limited by macro compile-time constraints |
| **Granularity** | ✅ Per-type configuration | ❌ Entire file affected | ⚠️ Global or per-module |
| **Discovery** | ❌ Requires parent lookup | ✅ File-level scan | ✅ Direct global access |
| **Performance** | ❌ AST traversal per macro | ✅ One-time file scan | ✅ Direct property access |
| **Migration** | ✅ Gradual per-type adoption | ⚠️ All-or-nothing per file | ✅ Global opt-in |
| **Debugging** | ✅ Clear type association | ❌ Hidden file-level effect | ❌ Hidden global effect |
| **Precedence** | ⚠️ Complex with inheritance | ✅ Simple hierarchy | ✅ Clear override hierarchy |
| **Runtime Flexibility** | ❌ Compile-time only | ❌ Compile-time only | ❌ Compile-time only (macro limitation) |
| **Module Isolation** | ✅ Natural type boundaries | ⚠️ File boundaries | ⚠️ Requires explicit module config |

## Recommendation

**Choose Combined Approach (Hybrid Model)** for optimal user experience and flexibility.

### Rationale

After evaluating all four approaches, the **Combined Approach** emerges as the best solution, addressing the key limitations of individual approaches:

**Why Combined Approach:**

1. **Superior User Experience**: Teams can set up defaults once per module/application and apply them broadly without repetitive configuration
2. **Flexible Granularity**: Supports global defaults for simplicity with type-level and method-level overrides for precision
3. **Natural Migration Path**: Start with global configuration, add type-level overrides only where needed
4. **Module Isolation**: Different modules can have different default configurations
5. **Familiar Patterns**: Combines well-known singleton pattern with Swift's attribute system
6. **Addresses Core Problem**: Eliminates the repetitive configuration issue more effectively than type-scoped alone

**Why Not Pure Type-Scoped:**
1. **Poor User Experience**: Requires configuration on every type, defeating the purpose of reducing repetition
2. **Migration Burden**: Teams must update every type individually, making adoption slower
3. **Inconsistency Risk**: Easy to forget configuration on some types, leading to inconsistent behavior

**Why Not Pure Instance-Based:**
1. **Limited Granularity**: Cannot override defaults for specific types without additional mechanisms
2. **Hidden Effects**: Global configuration can be surprising when debugging specific types

**Why Not File-Scoped:**
1. **Non-Swift-like**: File-scoped directives are uncommon in Swift ecosystem
2. **Inflexible Boundaries**: File organization doesn't always align with configuration needs

### Implementation Strategy

**Two-Phase Approach:**

1. **Instance Configuration Phase**: 
   - Teams set up module/global defaults using `AwaitlessConfig.setDefaults()`
   - Configuration is converted to compile-time constants for macro access
   - Module isolation supported through `AwaitlessConfig.setCurrent()`

2. **Macro Resolution Phase**:
   - Macros check for method-level parameters first
   - Then check for type-level `@AwaitlessConfig` 
   - Then access instance configuration compile-time constants
   - Finally fall back to built-in defaults

**Technical Implementation:**
```swift
// Generated compile-time constants from instance configuration
public enum AwaitlessGlobalConfig {
    public static let prefix: String? = "sync"  // From AwaitlessConfig.setDefaults()
    public static let availability: AwaitlessAvailability? = .deprecated()
    // ... other properties
}

// Type-level macro generates overrides
@AwaitlessConfig(prefix: "legacy")  // Generates static override properties
class DataService {
    static let __awaitlessConfig = AwaitlessConfigData(prefix: "legacy")
    
    @Awaitless  // Accesses: method params → type config → global config → defaults
    func fetchData() async throws -> Data { ... }
}
```

### Precedence Hierarchy

The four-level hierarchy provides clear, predictable behavior:

1. **Method Parameters** (highest priority) - explicit developer intent
2. **Type Configuration** - class/struct-specific overrides  
3. **Instance Configuration** - module/global defaults
4. **Built-in Defaults** (lowest priority) - sensible fallbacks

This hierarchy aligns with developer expectations: more specific configuration overrides more general configuration.

## Initial API Surface

```swift
// Configuration storage type
public struct AwaitlessConfigData {
    public let prefix: String?
    public let availability: AwaitlessAvailability?
    public let delivery: AwaitlessDelivery?
    public let strategy: AwaitlessSynchronizationStrategy?
    
    public init(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
}

// Configuration macro
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

## Examples

### Basic Configuration

**Combined Approach (Recommended):**
```swift
// One-time module setup
AwaitlessConfig.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version")
)

// Most classes need no configuration
class UserService {
    @Awaitless  // Uses global: syncFetchUser() with @available(*, deprecated)
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses global: syncStreamUserUpdates() with @available(*, deprecated)
    func streamUserUpdates() async -> AsyncStream<User> { ... }
}

// Type-level overrides when needed
@AwaitlessConfig(prefix: "legacy")
class LegacyService {
    @Awaitless  // Uses type override: legacyProcessData() with @available(*, deprecated)
    func processData() async throws -> Result { ... }
}
```

**Type-Scoped Only (Previous Recommendation):**
```swift
@AwaitlessConfig(prefix: "sync", availability: .deprecated())
class UserService {
    @Awaitless  // Generates: syncFetchUser() with @available(*, deprecated)
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Generates: syncStreamUserUpdates() with @available(*, deprecated)
    func streamUserUpdates() async -> AsyncStream<User> { ... }
}

// Every class needs configuration - repetitive!
@AwaitlessConfig(prefix: "sync", availability: .deprecated())
class OrderService {
    @Awaitless
    func fetchOrders() async throws -> [Order] { ... }
}
```

### Multiple Module Configuration

**Combined Approach:**
```swift
// NetworkModule setup
extension AwaitlessConfig {
    static let networking = AwaitlessConfig(
        prefix: "sync", 
        delivery: .current,
        availability: .deprecated()
    )
}
AwaitlessConfig.setCurrent(.networking)

class HTTPClient {
    @Awaitless  // Uses networking config: syncRequest() on .current with @available(*, deprecated)
    func request(_ url: URL) async throws -> Data { ... }
}

// DataModule setup  
extension AwaitlessConfig {
    static let dataProcessing = AwaitlessConfig(
        prefix: "blocking",
        delivery: .background
    )
}
AwaitlessConfig.setCurrent(.dataProcessing)

class DataProcessor {
    @Awaitless  // Uses dataProcessing config: blockingProcess() on .background
    func process(_ data: Data) async throws -> Result { ... }
}
```

### Overriding Defaults

**Type-Scoped:**
```swift
@AwaitlessConfig(prefix: "sync", delivery: .main)
class DataProcessor {
    @Awaitless  // Uses prefix="sync"
    func processData() async throws -> Result { ... }
    
    @Awaitless(prefix: "blocking")  // Override: uses prefix="blocking", keeps delivery=.main
    func heavyComputation() async throws -> BigResult { ... }
    
    @AwaitlessPublisher(deliverOn: .current)  // Override: uses deliverOn=.current, keeps prefix="sync"
    func lightweightStream() async -> AsyncStream<String> { ... }
}
```

**Instance-Based with Module Scoping (Conceptual):**
```swift
// Per-module configuration
extension AwaitlessConfig {
    static let dataProcessing = AwaitlessConfig(prefix: "sync", delivery: .main)
}

AwaitlessConfig.setCurrent(.dataProcessing)

class DataProcessor {
    @Awaitless  // Uses global prefix="sync", delivery=.main
    func processData() async throws -> Result { ... }
    
    @Awaitless(prefix: "blocking")  // Override: uses prefix="blocking", keeps global delivery=.main
    func heavyComputation() async throws -> BigResult { ... }
}
```

### Migration Example

**Before (current repetitive approach):**
```swift
class APIClient {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func userStream() async -> AsyncStream<User> { ... }
    
    @AwaitlessCompletion(prefix: "sync", .deprecated("Use async version"))
    func updateUser(_ user: User) async throws { ... }
}

class DataStore {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func saveUser(_ user: User) async throws { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func dataUpdates() async -> AsyncStream<DataUpdate> { ... }
}

// ... 20 more classes with identical repetitive configuration
```

**After (with combined approach):**
```swift
// One-time setup for entire module/app
AwaitlessConfig.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)

// All classes automatically use defaults - zero configuration needed
class APIClient {
    @Awaitless
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher
    func userStream() async -> AsyncStream<User> { ... }
    
    @AwaitlessCompletion
    func updateUser(_ user: User) async throws { ... }
}

class DataStore {
    @Awaitless
    func saveUser(_ user: User) async throws { ... }
    
    @AwaitlessPublisher
    func dataUpdates() async -> AsyncStream<DataUpdate> { ... }
}

// Special cases can still override
@AwaitlessConfig(prefix: "legacy")
class LegacyAPIClient {
    @Awaitless  // Uses prefix="legacy", keeps other global defaults
    func fetchLegacyData() async throws -> LegacyData { ... }
}
```

**Migration Impact:**
- **Before**: 40+ lines of repetitive configuration across 20 classes
- **After**: 4 lines of global setup + optional type-level overrides
- **Result**: 90% reduction in configuration boilerplate

## Future Considerations

1. **Nested Types**: How should configuration inheritance work for nested types?
2. **Extensions**: Should extensions inherit configuration from the original type?
3. **Protocols**: Can configuration be applied to protocol definitions?
4. **Module-Level**: Could configuration be expanded to module scope in the future?

### Instance-Based Configuration Exploration

While not recommended for the initial implementation, the instance-based approach raises interesting questions for future exploration:

**Multiple Instances Per SPM Module:**
```swift
// Different configurations for different areas within a module
extension AwaitlessConfig {
    static let networking = AwaitlessConfig(prefix: "sync", availability: .deprecated())
    static let dataProcessing = AwaitlessConfig(prefix: "blocking", delivery: .main)
    static let userInterface = AwaitlessConfig(prefix: "sync", delivery: .main)
}

// Usage could be file-scoped or type-scoped
#awaitlessConfig(.networking)  // File-scoped

@AwaitlessConfig(.dataProcessing)  // Type-scoped with instance
class DataProcessor { ... }
```

**Build-Time Configuration:**
```swift
// awaitless.config in SPM module
{
  "defaultPrefix": "sync",
  "defaultAvailability": "deprecated",
  "environments": {
    "testing": { "prefix": "test" },
    "production": { "prefix": "sync" }
  }
}

// Generated at build time:
extension AwaitlessConfig {
    static let buildDefaults = AwaitlessConfigData(
        prefix: "sync",
        availability: .deprecated()
    )
}
```

These approaches could be explored in future iterations once the foundational type-scoped approach is established.

### Approach 4: Combined Configuration (Hybrid Model)

#### Design

A hybrid approach that combines instance-based configuration for broad defaults with type-scoped configuration for granular control. This addresses the UX benefits of global/module configuration while maintaining the precision of type-level overrides.

```swift
// Module/process-level setup (once per module or app startup)
AwaitlessConfig.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)

// Type-level overrides when needed
@AwaitlessConfig(prefix: "legacy")  // Overrides global prefix, keeps other defaults
class LegacyDataService {
    @Awaitless  // Uses prefix="legacy", availability=.deprecated, delivery=.main
    func fetchOldData() async throws -> OldData { ... }
}

// Most types use global defaults without any configuration
class UserService {
    @Awaitless  // Uses global defaults: prefix="sync", availability=.deprecated
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses global defaults: prefix="sync", delivery=.main, availability=.deprecated
    func streamUsers() async -> AsyncStream<User> { ... }
}

// Method-level overrides still work
class DataProcessor {
    @Awaitless(prefix: "blocking")  // Overrides both global and type-level defaults
    func heavyProcessing() async throws -> Result { ... }
}
```

#### Multi-Module Configuration

```swift
// In NetworkModule
extension AwaitlessConfig {
    static let networking = AwaitlessConfig(
        prefix: "sync",
        availability: .deprecated("Use async version"),
        delivery: .current
    )
}

// Set per-module defaults
AwaitlessConfig.setCurrent(.networking)

// In DataModule  
extension AwaitlessConfig {
    static let dataProcessing = AwaitlessConfig(
        prefix: "blocking",
        delivery: .background
    )
}

AwaitlessConfig.setCurrent(.dataProcessing)
```

#### API Surface

```swift
public class AwaitlessConfig {
    // Global instance management
    public static let shared = AwaitlessConfig()
    public private(set) static var current: AwaitlessConfig = shared
    
    // Configuration properties
    public var prefix: String?
    public var availability: AwaitlessAvailability?
    public var delivery: AwaitlessDelivery?
    public var strategy: AwaitlessSynchronizationStrategy?
    
    // Instance management
    public static func setDefaults(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
    
    public static func setCurrent(_ config: AwaitlessConfig)
    public static func withConfig<T>(_ config: AwaitlessConfig, _ block: () throws -> T) rethrows -> T
}

// Type-level configuration macro (unchanged)
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

#### Precedence Rules (Four-Level Hierarchy)

1. **Method-level explicit parameters** - highest priority
2. **Type-level @AwaitlessConfig** - overrides instance defaults  
3. **Instance configuration** (`AwaitlessConfig.current`) - module/process defaults
4. **Built-in defaults** - lowest priority fallback

```swift
// Example precedence resolution
AwaitlessConfig.setDefaults(prefix: "sync", delivery: .main)  // Instance level

@AwaitlessConfig(prefix: "legacy")  // Type level - overrides instance prefix
class DataService {
    @Awaitless(delivery: .background)  // Method level - overrides both instance and type delivery
    func processData() async throws -> Result {
        // Generated method uses:
        // - prefix: "legacy" (from type-level)
        // - delivery: .background (from method-level)  
        // - availability: .deprecated (from instance-level, since not overridden)
    }
}
```

#### Implementation Strategy

**Compile-Time Constants Approach:**
```swift
// Instance configuration generates compile-time constants
public enum AwaitlessGlobalConfig {
    // Generated at build time or module initialization
    public static let prefix: String? = "sync"
    public static let availability: AwaitlessAvailability? = .deprecated("Use async version")
    public static let delivery: AwaitlessDelivery? = .main
}

// Macros access these constants during expansion
// @AwaitlessConfig generates type-level constants that override global ones
// Method parameters override both
```

**Module Isolation Strategy:**
```swift
// Each module can have its own generated config
// In MyNetworkModule:
extension AwaitlessGlobalConfig {
    // Generated based on AwaitlessConfig.setCurrent() calls in module
    static let modulePrefix: String? = "net"
    static let moduleDelivery: AwaitlessDelivery? = .current
}
```

#### Advantages

**User Experience Benefits:**
- **One-Time Setup**: Configure defaults once per module or application
- **Broad Coverage**: Global configuration applies to all types without annotation
- **Gradual Migration**: Can start with global config, add type-level as needed
- **Module Isolation**: Different modules can have different defaults

**Technical Benefits:**
- **Macro Compatibility**: Works within compile-time constraints
- **Clear Precedence**: Four-level hierarchy is intuitive and predictable
- **Flexibility**: Supports both broad and granular configuration needs
- **Performance**: Minimal overhead during macro expansion

#### Challenges

**Implementation Complexity:**
- **Two-Phase System**: Requires coordination between instance config and macro system
- **Build Integration**: May need build-time code generation for compile-time constants
- **Module Boundaries**: Ensuring proper isolation between module configurations

**Migration Considerations:**
- **Configuration Discovery**: Users need to understand where defaults come from
- **Debugging**: Four-level precedence may be complex to debug
- **Documentation**: Requires clear explanation of precedence rules

#### Usage Examples

**Simple Global Setup:**
```swift
// App initialization or module setup
AwaitlessConfig.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version")
)

// Throughout the app - no configuration needed
class APIClient {
    @Awaitless  // Uses global defaults
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher  // Uses global defaults
    func userUpdates() async -> AsyncStream<User> { ... }
}

class DataStore {
    @Awaitless  // Uses global defaults  
    func saveUser(_ user: User) async throws { ... }
}
```

**Module-Specific Configuration:**
```swift
// In NetworkingModule
extension AwaitlessConfig {
    static let networking = AwaitlessConfig(
        prefix: "sync",
        delivery: .current,
        availability: .deprecated()
    )
}

// Module setup
AwaitlessConfig.setCurrent(.networking)

// All networking classes use module defaults
class HTTPClient {
    @Awaitless  // prefix="sync", delivery=.current, availability=.deprecated
    func request(_ url: URL) async throws -> Data { ... }
}

class WebSocketClient {
    @AwaitlessPublisher  // Same module defaults
    func connect() async -> AsyncStream<Message> { ... }
}
```

**Granular Overrides:**
```swift
// Global defaults
AwaitlessConfig.setDefaults(prefix: "sync", availability: .deprecated())

// Type-level override for special cases
@AwaitlessConfig(prefix: "legacy", delivery: .main)
class LegacyAPIClient {
    @Awaitless  // prefix="legacy", delivery=.main, availability=.deprecated
    func oldRequest() async throws -> OldData { ... }
    
    @Awaitless(prefix: "blocking")  // Method-level override: prefix="blocking", keeps type/global defaults
    func heavyRequest() async throws -> BigData { ... }
}
```

## Comparison Matrix (Updated)

| Aspect | Type-Scoped | File-Scoped | Instance-Based | **Combined Approach** |
|--------|-------------|-------------|----------------|-----------------------|
| **Swift Idioms** | ✅ Natural type-based | ❌ Unusual file-level | ✅ Familiar singleton | ✅ Best of both worlds |
| **Implementation** | ❌ Complex AST traversal | ⚠️ Source text parsing | ❌ Macro limitations | ⚠️ Two-phase system |
| **Granularity** | ✅ Per-type | ❌ Per-file | ⚠️ Global/module | ✅ Four-level hierarchy |
| **User Experience** | ❌ Repetitive per-type | ⚠️ Per-file setup | ✅ One-time setup | ✅ Setup once, override as needed |
| **Discovery** | ❌ Requires parent lookup | ✅ File-level scan | ✅ Direct global access | ✅ Clear precedence chain |
| **Performance** | ❌ AST traversal | ✅ One-time file scan | ✅ Direct access | ✅ Compile-time constants |
| **Migration** | ❌ All-or-nothing per type | ⚠️ Per-file | ✅ Global opt-in | ✅ Gradual: global → type → method |
| **Debugging** | ✅ Clear type association | ❌ Hidden file effect | ❌ Hidden global effect | ⚠️ Four-level complexity |
| **Module Isolation** | ✅ Natural boundaries | ⚠️ File boundaries | ⚠️ Requires explicit config | ✅ Module-specific instances |
| **Configuration Overhead** | ❌ Required per type | ❌ Required per file | ✅ Optional global | ✅ Optional at all levels |

## Conclusion

The **Combined Approach** provides the optimal balance of user experience, flexibility, and Swift idioms. By combining instance-based configuration for broad defaults with type-scoped configuration for granular control, it addresses the core problem of repetitive configuration while maintaining the precision and clarity that Swift developers expect.

The four-level precedence hierarchy (method → type → instance → defaults) provides intuitive behavior that aligns with developer expectations, while the module isolation capabilities support complex application architectures.