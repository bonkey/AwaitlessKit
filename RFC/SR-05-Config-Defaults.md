# RFC SR-05: Configuration Defaults

**Status**: Draft  
**Author**: Generated by Copilot  
**Date**: 2025-01-03  

## Summary

Design an opt-in configuration mechanism for AwaitlessKit defaults (e.g., prefix, default output type, delivery) to enable teams to set consistent defaults at type or file scope without repeating attributes everywhere.

## Motivation

Currently, AwaitlessKit macros require explicit specification of common parameters on every usage:

```swift
class DataService {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func streamData() async throws -> [Data] { ... }
    
    @AwaitlessCompletion(prefix: "sync", .deprecated("Use async version"))
    func processData() async throws -> Result { ... }
}
```

This leads to repetitive code and inconsistent configurations across teams. A configuration mechanism would allow teams to establish consistent defaults while maintaining override capabilities.

## Design Approaches

### Approach 1: Type-Scoped Configuration

#### Design

A new `@AwaitlessConfig` attribute that can be applied to types (classes, structs, actors) to establish defaults for all contained async methods.

```swift
@AwaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)
class DataService {
    @Awaitless  // Uses defaults: prefix="sync", availability=.deprecated
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses defaults: prefix="sync", delivery=.main, availability=.deprecated
    func streamData() async throws -> [Data] { ... }
    
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other defaults
    func oldMethod() async throws -> String { ... }
}
```

#### API Surface

```swift
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **Type-level @AwaitlessConfig** provides defaults for the type
3. **Built-in defaults** are used when neither method nor type specifies a value

#### Macro Implementation Challenges

**Pros:**
- Natural scoping model aligns with Swift's type system
- Clear ownership and visibility of configuration
- Can be discovered through macro context's parent declarations

**Cons:**
- **Macro Discovery Complexity**: Attached macros need to traverse up the syntax tree to find `@AwaitlessConfig` on the containing type
- **Multiple Inheritance**: If a type has nested types, precedence becomes complex
- **Performance**: Each macro invocation requires AST traversal to find configuration

### Approach 2: File-Scoped Configuration

#### Design

A file-scoped freestanding macro `#awaitlessConfig` that establishes defaults for all AwaitlessKit macros in the same file.

```swift
#awaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"), 
    delivery: .main
)

class DataService {
    @Awaitless  // Uses file defaults
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses file defaults
    func streamData() async throws -> [Data] { ... }
}

class NetworkService {
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other file defaults
    func request() async throws -> Response { ... }
}
```

#### API Surface

```swift
@freestanding(declaration)
public macro awaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **File-level #awaitlessConfig** provides defaults for the entire file  
3. **Built-in defaults** are used when neither method nor file specifies a value

#### Macro Implementation Challenges

**Pros:**
- **Simpler Discovery**: File-scoped configuration can be found by scanning source file
- **Clear Boundaries**: One configuration per file, no inheritance complexity
- **Performance**: Configuration lookup is straightforward

**Cons:**
- **Non-Swift-like**: File-scoped directives are uncommon in Swift
- **Global State**: Configuration affects entire file, which may be surprising
- **Limited Granularity**: Cannot have different defaults for different types in same file

## Feasibility Analysis

### Macro Context Limitations

Swift macros have limited ability to access information outside their immediate context:

1. **No Global State**: Macros cannot share state between invocations
2. **Limited AST Access**: Cannot easily traverse to sibling or parent declarations
3. **Expansion Order**: No guarantee about the order of macro expansion

### Technical Approach Options

#### Option A: Syntax Tree Traversal (Type-scoped)

```swift
// In AwaitlessSyncMacro
public static func expansion(
    of node: AttributeSyntax,
    providingPeersOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
) throws -> [DeclSyntax] {
    // Look for @AwaitlessConfig on containing type
    let containingType = findContainingType(declaration, in: context)
    let config = extractConfig(from: containingType)
    // Merge with explicit parameters...
}
```

**Challenges**: Requires complex AST traversal, may not work reliably across different syntax contexts.

#### Option B: Generated Configuration Storage (Type-scoped)

```swift
@AwaitlessConfig(prefix: "sync")
class DataService {
    // Generated by @AwaitlessConfig:
    static let __awaitlessConfig = AwaitlessConfigData(prefix: "sync", ...)
    
    @Awaitless  // Can access DataService.__awaitlessConfig
    func fetchUser() async throws -> User { ... }
}
```

**Challenges**: Requires coordination between `@AwaitlessConfig` and other macros.

#### Option C: Source Text Analysis (File-scoped)

```swift
// In any AwaitlessKit macro
public static func expansion(
    of node: AttributeSyntax,
    providingPeersOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
) throws -> [DeclSyntax] {
    // Parse source file text for #awaitlessConfig
    let config = parseConfigFromSource(context.sourceFile)
    // Merge with explicit parameters...
}
```

**Challenges**: Fragile text parsing, source file access limitations.

## Comparison Matrix

| Aspect | Type-Scoped (@AwaitlessConfig) | File-Scoped (#awaitlessConfig) |
|--------|-------------------------------|--------------------------------|
| **Swift Idioms** | ✅ Natural type-based scoping | ❌ Unusual file-level directive |
| **Implementation** | ❌ Complex AST traversal | ⚠️ Source text parsing |
| **Granularity** | ✅ Per-type configuration | ❌ Entire file affected |
| **Discovery** | ❌ Requires parent lookup | ✅ File-level scan |
| **Performance** | ❌ AST traversal per macro | ✅ One-time file scan |
| **Migration** | ✅ Gradual per-type adoption | ⚠️ All-or-nothing per file |
| **Debugging** | ✅ Clear type association | ❌ Hidden file-level effect |
| **Precedence** | ⚠️ Complex with inheritance | ✅ Simple hierarchy |

## Recommendation

**Choose Type-Scoped Approach (@AwaitlessConfig)** despite implementation complexity.

### Rationale

1. **Swift Consistency**: Aligns with Swift's type-based attribute system
2. **Better Granularity**: Teams can configure different types differently 
3. **Clear Ownership**: Configuration is visibly associated with types
4. **Migration Path**: Can be adopted incrementally per type

### Implementation Strategy

Use **Generated Configuration Storage** approach:

1. `@AwaitlessConfig` generates a static property storing configuration
2. Other macros look for this property on the containing type
3. Fall back to built-in defaults if not found

## Initial API Surface

```swift
// Configuration storage type
public struct AwaitlessConfigData {
    public let prefix: String?
    public let availability: AwaitlessAvailability?
    public let delivery: AwaitlessDelivery?
    public let strategy: AwaitlessSynchronizationStrategy?
    
    public init(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
}

// Configuration macro
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

## Examples

### Basic Configuration

```swift
@AwaitlessConfig(prefix: "sync", availability: .deprecated())
class UserService {
    @Awaitless  // Generates: syncFetchUser() with @available(*, deprecated)
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Generates: syncStreamUserUpdates() with @available(*, deprecated)
    func streamUserUpdates() async -> AsyncStream<User> { ... }
}
```

### Overriding Defaults

```swift
@AwaitlessConfig(prefix: "sync", delivery: .main)
class DataProcessor {
    @Awaitless  // Uses prefix="sync"
    func processData() async throws -> Result { ... }
    
    @Awaitless(prefix: "blocking")  // Override: uses prefix="blocking", keeps delivery=.main
    func heavyComputation() async throws -> BigResult { ... }
    
    @AwaitlessPublisher(deliverOn: .current)  // Override: uses deliverOn=.current, keeps prefix="sync"
    func lightweightStream() async -> AsyncStream<String> { ... }
}
```

### Migration Example

**Before (current repetitive approach):**
```swift
class APIClient {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func userStream() async -> AsyncStream<User> { ... }
    
    @AwaitlessCompletion(prefix: "sync", .deprecated("Use async version"))
    func updateUser(_ user: User) async throws { ... }
}
```

**After (with configuration):**
```swift
@AwaitlessConfig(prefix: "sync", availability: .deprecated("Use async version"), delivery: .main)
class APIClient {
    @Awaitless
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher
    func userStream() async -> AsyncStream<User> { ... }
    
    @AwaitlessCompletion
    func updateUser(_ user: User) async throws { ... }
}
```

## Future Considerations

1. **Nested Types**: How should configuration inheritance work for nested types?
2. **Extensions**: Should extensions inherit configuration from the original type?
3. **Protocols**: Can configuration be applied to protocol definitions?
4. **Module-Level**: Could configuration be expanded to module scope in the future?

## Conclusion

The type-scoped `@AwaitlessConfig` approach provides the best balance of Swift idioms, granular control, and clear semantics despite implementation challenges. The generated configuration storage strategy offers a viable path forward while maintaining compatibility with Swift's macro system limitations.