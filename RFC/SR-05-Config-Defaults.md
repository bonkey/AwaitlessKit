# RFC SR-05: Configuration Defaults

**Status**: Draft  
**Author**: Generated by Copilot  
**Date**: 2025-01-03  

## Summary

Design an opt-in configuration mechanism for AwaitlessKit defaults (e.g., prefix, default output type, delivery) to enable teams to set consistent defaults at type or file scope without repeating attributes everywhere.

## Motivation

Currently, AwaitlessKit macros require explicit specification of common parameters on every usage:

```swift
class DataService {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func streamData() async throws -> [Data] { ... }
    
    @AwaitlessCompletion(prefix: "sync", .deprecated("Use async version"))
    func processData() async throws -> Result { ... }
}
```

This leads to repetitive code and inconsistent configurations across teams. A configuration mechanism would allow teams to establish consistent defaults while maintaining override capabilities.

## Design Approaches

### Approach 1: Type-Scoped Configuration

#### Design

A new `@AwaitlessConfig` attribute that can be applied to types (classes, structs, actors) to establish defaults for all contained async methods.

```swift
@AwaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)
class DataService {
    @Awaitless  // Uses defaults: prefix="sync", availability=.deprecated
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses defaults: prefix="sync", delivery=.main, availability=.deprecated
    func streamData() async throws -> [Data] { ... }
    
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other defaults
    func oldMethod() async throws -> String { ... }
}
```

#### API Surface

```swift
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **Type-level @AwaitlessConfig** provides defaults for the type
3. **Built-in defaults** are used when neither method nor type specifies a value

#### Macro Implementation Challenges

**Pros:**
- Natural scoping model aligns with Swift's type system
- Clear ownership and visibility of configuration
- Can be discovered through macro context's parent declarations

**Cons:**
- **Macro Discovery Complexity**: Attached macros need to traverse up the syntax tree to find `@AwaitlessConfig` on the containing type
- **Multiple Inheritance**: If a type has nested types, precedence becomes complex
- **Performance**: Each macro invocation requires AST traversal to find configuration

### Approach 2: File-Scoped Configuration

#### Design

A file-scoped freestanding macro `#awaitlessConfig` that establishes defaults for all AwaitlessKit macros in the same file.

```swift
#awaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"), 
    delivery: .main
)

class DataService {
    @Awaitless  // Uses file defaults
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses file defaults
    func streamData() async throws -> [Data] { ... }
}

class NetworkService {
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other file defaults
    func request() async throws -> Response { ... }
}
```

#### API Surface

```swift
@freestanding(declaration)
public macro awaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **File-level #awaitlessConfig** provides defaults for the entire file  
3. **Built-in defaults** are used when neither method nor file specifies a value

#### Macro Implementation Challenges

**Pros:**
- **Simpler Discovery**: File-scoped configuration can be found by scanning source file
- **Clear Boundaries**: One configuration per file, no inheritance complexity
- **Performance**: Configuration lookup is straightforward

**Cons:**
- **Non-Swift-like**: File-scoped directives are uncommon in Swift
- **Global State**: Configuration affects entire file, which may be surprising
- **Limited Granularity**: Cannot have different defaults for different types in same file

## Feasibility Analysis

### Macro Context Limitations

Swift macros have limited ability to access information outside their immediate context:

1. **No Global State**: Macros cannot share state between invocations
2. **Limited AST Access**: Cannot easily traverse to sibling or parent declarations
3. **Expansion Order**: No guarantee about the order of macro expansion

### Technical Approach Options

#### Option A: Syntax Tree Traversal (Type-scoped)

```swift
// In AwaitlessSyncMacro
public static func expansion(
    of node: AttributeSyntax,
    providingPeersOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
) throws -> [DeclSyntax] {
    // Look for @AwaitlessConfig on containing type
    let containingType = findContainingType(declaration, in: context)
    let config = extractConfig(from: containingType)
    // Merge with explicit parameters...
}
```

**Challenges**: Requires complex AST traversal, may not work reliably across different syntax contexts.

#### Option B: Generated Configuration Storage (Type-scoped)

```swift
@AwaitlessConfig(prefix: "sync")
class DataService {
    // Generated by @AwaitlessConfig:
    static let __awaitlessConfig = AwaitlessConfigData(prefix: "sync", ...)
    
    @Awaitless  // Can access DataService.__awaitlessConfig
    func fetchUser() async throws -> User { ... }
}
```

**Challenges**: Requires coordination between `@AwaitlessConfig` and other macros.

#### Option C: Source Text Analysis (File-scoped)

```swift
// In any AwaitlessKit macro
public static func expansion(
    of node: AttributeSyntax,
    providingPeersOf declaration: some DeclSyntaxProtocol,
    in context: some MacroExpansionContext
) throws -> [DeclSyntax] {
    // Parse source file text for #awaitlessConfig
    let config = parseConfigFromSource(context.sourceFile)
    // Merge with explicit parameters...
}
```

**Challenges**: Fragile text parsing, source file access limitations.

### Approach 3: Instance-Based Configuration

#### Design

A global or module-scoped configuration instance that provides defaults for all AwaitlessKit macros. Configuration can be set through a singleton or multiple instances per module.

```swift
// Global singleton approach
AwaitlessConfig.shared.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)

class DataService {
    @Awaitless  // Uses AwaitlessConfig.shared defaults
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses AwaitlessConfig.shared defaults
    func streamData() async throws -> [Data] { ... }
    
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other global defaults
    func oldMethod() async throws -> String { ... }
}
```

Alternative module-scoped approach:
```swift
// Per-module configuration
extension AwaitlessConfig {
    static let dataModule = AwaitlessConfig(
        prefix: "sync",
        availability: .deprecated("Use async version")
    )
}

// Set as current for this module/file
AwaitlessConfig.setCurrent(.dataModule)

class DataService {
    @Awaitless  // Uses AwaitlessConfig.dataModule defaults
    func fetchUser(id: String) async throws -> User { ... }
}
```

#### API Surface

```swift
public class AwaitlessConfig {
    public static let shared = AwaitlessConfig()
    public private(set) static var current: AwaitlessConfig = shared
    
    public var prefix: String?
    public var availability: AwaitlessAvailability?
    public var delivery: AwaitlessDelivery?
    public var strategy: AwaitlessSynchronizationStrategy?
    
    public init(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
    
    public func setDefaults(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
    
    public static func setCurrent(_ config: AwaitlessConfig)
    public static func withConfig<T>(_ config: AwaitlessConfig, _ block: () throws -> T) rethrows -> T
}
```

#### Precedence Rules

1. **Method-level explicit parameters** override all defaults
2. **Type-level @AwaitlessConfig** (if present) overrides instance defaults
3. **Instance configuration** (`AwaitlessConfig.current`) provides base defaults
4. **Built-in defaults** are used when no configuration specifies a value

#### Macro Implementation Challenges

**Pros:**
- **Simplest Integration**: Macros can directly access global state for defaults
- **Runtime Flexibility**: Configuration can be changed at runtime
- **Module Scoping**: Can support different configs per module via `setCurrent()`
- **No AST Traversal**: No complex syntax tree navigation required
- **Familiar Pattern**: Similar to other Swift configuration systems

**Cons:**
- **Global State**: Introduces shared mutable state, potential for unexpected behavior
- **Macro Limitations**: Swift macros have limited access to runtime state during compilation
- **Thread Safety**: Requires careful synchronization in multi-threaded environments
- **Testing Complexity**: Global state can make tests harder to isolate
- **Compile-Time Only**: Configuration must be deterministic at macro expansion time

#### Technical Feasibility Concerns

**Critical Challenge**: Swift macros execute during compilation, not runtime. They cannot access mutable global state that changes during program execution. Any instance-based approach would need to:

1. **Compile-Time Configuration**: The configuration must be statically determinable at macro expansion time
2. **Source Generation**: Use compile-time constants or generate configuration code
3. **Build System Integration**: Potentially require build-time configuration injection

**Possible Implementation Strategies:**

**Strategy A: Compile-Time Constants**
```swift
// Must be compile-time constant
public enum AwaitlessConfig {
    public static let prefix: String = "sync"  // Set at compile time
    public static let availability: AwaitlessAvailability = .deprecated("Use async version")
}
```

**Strategy B: Build Configuration**
```swift
// Generated during build from external config
// awaitless.config.swift (generated)
extension AwaitlessConfig {
    static let buildTimeDefaults = AwaitlessConfigData(
        prefix: "sync",
        availability: .deprecated("Use async version")
    )
}
```

**Strategy C: Module-Level Constants**
```swift
// Each module defines its own constants
public enum DataServiceConfig {
    public static let awaitlessPrefix = "sync"
    public static let awaitlessAvailability = AwaitlessAvailability.deprecated("Use async version")
}

// Macros use these constants as defaults
@Awaitless  // Automatically uses DataServiceConfig values if available
func fetchUser() async throws -> User { ... }
```

## Comparison Matrix

| Aspect | Type-Scoped (@AwaitlessConfig) | File-Scoped (#awaitlessConfig) | Instance-Based (AwaitlessConfig) |
|--------|-------------------------------|--------------------------------|----------------------------------|
| **Swift Idioms** | ✅ Natural type-based scoping | ❌ Unusual file-level directive | ✅ Familiar singleton pattern |
| **Implementation** | ❌ Complex AST traversal | ⚠️ Source text parsing | ❌ Limited by macro compile-time constraints |
| **Granularity** | ✅ Per-type configuration | ❌ Entire file affected | ⚠️ Global or per-module |
| **Discovery** | ❌ Requires parent lookup | ✅ File-level scan | ✅ Direct global access |
| **Performance** | ❌ AST traversal per macro | ✅ One-time file scan | ✅ Direct property access |
| **Migration** | ✅ Gradual per-type adoption | ⚠️ All-or-nothing per file | ✅ Global opt-in |
| **Debugging** | ✅ Clear type association | ❌ Hidden file-level effect | ❌ Hidden global effect |
| **Precedence** | ⚠️ Complex with inheritance | ✅ Simple hierarchy | ✅ Clear override hierarchy |
| **Runtime Flexibility** | ❌ Compile-time only | ❌ Compile-time only | ❌ Compile-time only (macro limitation) |
| **Module Isolation** | ✅ Natural type boundaries | ⚠️ File boundaries | ⚠️ Requires explicit module config |

## Recommendation

**Choose Type-Scoped Approach (@AwaitlessConfig)** despite implementation complexity.

### Rationale

While the **Instance-Based Configuration** approach offers appealing simplicity, it faces fundamental limitations with Swift's macro system:

**Why Not Instance-Based:**
1. **Macro Compile-Time Constraint**: Swift macros cannot access mutable runtime state during compilation, severely limiting the flexibility of instance-based configuration
2. **Hidden Global Effects**: Configuration changes affect code behavior in non-obvious ways, making debugging harder
3. **Build Complexity**: Truly dynamic instance configuration would require complex build system integration

**Why Not File-Scoped:**
1. **Non-Swift-like**: File-scoped directives are uncommon in Swift ecosystem
2. **Limited Granularity**: Cannot configure different types differently within the same file
3. **Hidden Effects**: File-level configuration can be surprising and hard to discover

**Why Type-Scoped:**
1. **Swift Consistency**: Aligns with Swift's type-based attribute system and follows established patterns
2. **Better Granularity**: Teams can configure different types differently, providing precise control
3. **Clear Ownership**: Configuration is visibly associated with types, making behavior explicit
4. **Migration Path**: Can be adopted incrementally per type without breaking existing code
5. **Future-Proof**: Doesn't rely on global state or build system extensions

### Implementation Strategy

Use **Generated Configuration Storage** approach:

1. `@AwaitlessConfig` generates a static property storing configuration
2. Other macros look for this property on the containing type
3. Fall back to built-in defaults if not found

### Acknowledgment of Instance-Based Benefits

The instance-based approach does offer compelling advantages:
- **Simplicity**: Direct parameter passing to macros would be straightforward
- **Familiarity**: Singleton patterns are well-understood by Swift developers
- **Module Isolation**: Could support different configurations per SPM module

However, these benefits are outweighed by the fundamental compile-time limitations of Swift macros and the potential for hidden behavioral changes through global state.

## Initial API Surface

```swift
// Configuration storage type
public struct AwaitlessConfigData {
    public let prefix: String?
    public let availability: AwaitlessAvailability?
    public let delivery: AwaitlessDelivery?
    public let strategy: AwaitlessSynchronizationStrategy?
    
    public init(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
}

// Configuration macro
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

## Examples

### Basic Configuration

**Type-Scoped:**
```swift
@AwaitlessConfig(prefix: "sync", availability: .deprecated())
class UserService {
    @Awaitless  // Generates: syncFetchUser() with @available(*, deprecated)
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Generates: syncStreamUserUpdates() with @available(*, deprecated)
    func streamUserUpdates() async -> AsyncStream<User> { ... }
}
```

**Instance-Based (Conceptual):**
```swift
// Module setup (would need to be compile-time deterministic)
AwaitlessConfig.shared.setDefaults(
    prefix: "sync",
    availability: .deprecated()
)

class UserService {
    @Awaitless  // Generates: syncFetchUser() with @available(*, deprecated)
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Generates: syncStreamUserUpdates() with @available(*, deprecated)  
    func streamUserUpdates() async -> AsyncStream<User> { ... }
}
```

### Overriding Defaults

**Type-Scoped:**
```swift
@AwaitlessConfig(prefix: "sync", delivery: .main)
class DataProcessor {
    @Awaitless  // Uses prefix="sync"
    func processData() async throws -> Result { ... }
    
    @Awaitless(prefix: "blocking")  // Override: uses prefix="blocking", keeps delivery=.main
    func heavyComputation() async throws -> BigResult { ... }
    
    @AwaitlessPublisher(deliverOn: .current)  // Override: uses deliverOn=.current, keeps prefix="sync"
    func lightweightStream() async -> AsyncStream<String> { ... }
}
```

**Instance-Based with Module Scoping (Conceptual):**
```swift
// Per-module configuration
extension AwaitlessConfig {
    static let dataProcessing = AwaitlessConfig(prefix: "sync", delivery: .main)
}

AwaitlessConfig.setCurrent(.dataProcessing)

class DataProcessor {
    @Awaitless  // Uses global prefix="sync", delivery=.main
    func processData() async throws -> Result { ... }
    
    @Awaitless(prefix: "blocking")  // Override: uses prefix="blocking", keeps global delivery=.main
    func heavyComputation() async throws -> BigResult { ... }
}
```

### Migration Example

**Before (current repetitive approach):**
```swift
class APIClient {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func userStream() async -> AsyncStream<User> { ... }
    
    @AwaitlessCompletion(prefix: "sync", .deprecated("Use async version"))
    func updateUser(_ user: User) async throws { ... }
}
```

**After (with configuration):**
```swift
@AwaitlessConfig(prefix: "sync", availability: .deprecated("Use async version"), delivery: .main)
class APIClient {
    @Awaitless
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher
    func userStream() async -> AsyncStream<User> { ... }
    
    @AwaitlessCompletion
    func updateUser(_ user: User) async throws { ... }
}
```

## Future Considerations

1. **Nested Types**: How should configuration inheritance work for nested types?
2. **Extensions**: Should extensions inherit configuration from the original type?
3. **Protocols**: Can configuration be applied to protocol definitions?
4. **Module-Level**: Could configuration be expanded to module scope in the future?

### Instance-Based Configuration Exploration

While not recommended for the initial implementation, the instance-based approach raises interesting questions for future exploration:

**Multiple Instances Per SPM Module:**
```swift
// Different configurations for different areas within a module
extension AwaitlessConfig {
    static let networking = AwaitlessConfig(prefix: "sync", availability: .deprecated())
    static let dataProcessing = AwaitlessConfig(prefix: "blocking", delivery: .main)
    static let userInterface = AwaitlessConfig(prefix: "sync", delivery: .main)
}

// Usage could be file-scoped or type-scoped
#awaitlessConfig(.networking)  // File-scoped

@AwaitlessConfig(.dataProcessing)  // Type-scoped with instance
class DataProcessor { ... }
```

**Build-Time Configuration:**
```swift
// awaitless.config in SPM module
{
  "defaultPrefix": "sync",
  "defaultAvailability": "deprecated",
  "environments": {
    "testing": { "prefix": "test" },
    "production": { "prefix": "sync" }
  }
}

// Generated at build time:
extension AwaitlessConfig {
    static let buildDefaults = AwaitlessConfigData(
        prefix: "sync",
        availability: .deprecated()
    )
}
```

These approaches could be explored in future iterations once the foundational type-scoped approach is established.

## Conclusion

The type-scoped `@AwaitlessConfig` approach provides the best balance of Swift idioms, granular control, and clear semantics despite implementation challenges. The generated configuration storage strategy offers a viable path forward while maintaining compatibility with Swift's macro system limitations.