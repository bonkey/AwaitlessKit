# RFC SR-05: Configuration Defaults

**Status**: Draft  
**Author**: Generated by Copilot  
**Date**: 2025-01-03  

## Summary

Design an opt-in configuration mechanism for AwaitlessKit defaults (e.g., prefix, default output type, delivery) to enable teams to set consistent defaults at type or module scope without repeating attributes everywhere.

## Problem Statement

Currently, AwaitlessKit macros require explicit specification of common parameters on every usage, leading to repetitive code and inconsistent configurations across teams:

```swift
class APIClient {
    @Awaitless(prefix: "sync", .deprecated("Use async version"))
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher(prefix: "sync", deliverOn: .main, .deprecated("Use async version"))
    func userStream() async -> AsyncStream<User> { ... }
    
    @AwaitlessCompletion(prefix: "sync", .deprecated("Use async version"))
    func updateUser(_ user: User) async throws { ... }
}

// ... 20+ more classes with identical repetitive configuration
```

This results in:
- **Extensive configuration boilerplate** across large codebases
- **Inconsistency risk** when teams forget to apply common patterns
- **Poor maintainability** when configuration patterns need to change
- **Slow adoption** due to verbose setup requirements

## Solution Overview

This RFC proposes a **Combined Approach** that merges instance-based configuration for broad defaults with type-scoped configuration for granular control:

```swift
// One-time process setup
AwaitlessConfig.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)

// Most classes need no configuration - uses global defaults automatically
class APIClient {
    @Awaitless  // Uses global defaults automatically
    func fetchUsers() async throws -> [User] { ... }
    
    @AwaitlessPublisher  // Uses global defaults automatically
    func userStream() async -> AsyncStream<User> { ... }
}

// Type-level overrides when needed
@AwaitlessConfig(prefix: "legacy")
class LegacyService {
    @Awaitless  // Uses type override with global fallbacks
    func processData() async throws -> Result { ... }
}
```

## Approaches Evaluated

### Approach 1: Type-Scoped Configuration

#### Design

A new `@AwaitlessConfig` attribute that can be applied to types (classes, structs, actors) to establish defaults for all contained async methods.

```swift
@AwaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)
class DataService {
    @Awaitless  // Uses defaults: prefix="sync", availability=.deprecated
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses defaults: prefix="sync", delivery=.main, availability=.deprecated
    func streamData() async throws -> [Data] { ... }
    
    @Awaitless(prefix: "legacy")  // Override: prefix="legacy", keeps other defaults
    func oldMethod() async throws -> String { ... }
}
```

#### Pros & Cons

**Pros:**
- Natural scoping model aligns with Swift's type system
- Clear ownership and visibility of configuration
- Can be discovered through macro context's parent declarations

**Cons:**
- **Poor User Experience**: Requires configuration on every type, defeating the purpose
- **Migration Burden**: Teams must update every type individually
- **Macro Discovery Complexity**: Requires AST traversal to find configuration
- **Inconsistency Risk**: Easy to forget configuration on some types

### Approach 2: File-Scoped Configuration

#### Design

A file-scoped freestanding macro `#awaitlessConfig` that establishes defaults for all AwaitlessKit macros in the same file.

```swift
#awaitlessConfig(
    prefix: "sync",
    availability: .deprecated("Use async version"), 
    delivery: .main
)

class DataService {
    @Awaitless  // Uses file defaults
    func fetchUser(id: String) async throws -> User { ... }
}
```

#### Pros & Cons

**Pros:**
- Simpler discovery than type-scoped approach
- One configuration per file reduces complexity

**Cons:**
- **Non-Swift-like**: File-scoped directives are uncommon in Swift
- **Inflexible Boundaries**: File organization doesn't align with configuration needs
- **Limited Granularity**: Cannot have different defaults for different types in same file

### Approach 3: Instance-Based Configuration

#### Design

A global or module-scoped configuration instance that provides defaults for all AwaitlessKit macros.

```swift
// Global singleton approach
AwaitlessConfig.shared.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)

class DataService {
    @Awaitless  // Uses AwaitlessConfig.shared defaults
    func fetchUser(id: String) async throws -> User { ... }
}
```

#### Pros & Cons

**Pros:**
- **Superior User Experience**: Set up once per module/process
- **Familiar Pattern**: Similar to other Swift configuration systems
- **No AST Traversal**: Direct property access during macro expansion

**Cons:**
- **Global State**: Introduces shared mutable state
- **Macro Limitations**: Swift macros have limited access to runtime state during compilation

### Approach 4: Combined Configuration (Recommended)

#### Design

A hybrid approach that combines instance-based configuration for broad defaults with type-scoped configuration for granular control.

```swift
// Module/process-level setup (once per app startup)
AwaitlessConfig.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version"),
    delivery: .main
)

// Most types use global defaults without any configuration
class UserService {
    @Awaitless  // Uses global defaults: prefix="sync", availability=.deprecated
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses global defaults: prefix="sync", delivery=.main, availability=.deprecated
    func streamUsers() async -> AsyncStream<User> { ... }
}

// Type-level overrides when needed
@AwaitlessConfig(prefix: "legacy")  // Overrides global prefix, keeps other defaults
class LegacyDataService {
    @Awaitless  // Uses prefix="legacy", availability=.deprecated, delivery=.main
    func fetchOldData() async throws -> OldData { ... }
}

// Example with both attributes on the class
@AwaitlessConfig(prefix: "legacy", availability: .deprecated("Legacy API"))
@Awaitless  // Applies config to all methods in this class
class LegacyService {
    // Creates: @deprecated("Legacy API") func legacy_processData() -> ProcessResult
    func processData() async throws -> ProcessResult { ... }
    
    // Creates: @deprecated("Legacy API") func legacy_validateInput() -> Bool  
    func validateInput() async throws -> Bool { ... }
}

// Method-level overrides still work
class DataProcessor {
    @Awaitless(prefix: "blocking")  // Overrides both global and type-level defaults
    func heavyProcessing() async throws -> Result { ... }
}
```

## Recommended Solution: Combined Approach

### Rationale

After evaluating all approaches, the **Combined Approach** emerges as the optimal solution:

1. **Superior User Experience**: Teams set defaults once per application with broad application
2. **Flexible Granularity**: Four-level precedence hierarchy supports both simplicity and precision
3. **Natural Migration Path**: Start with global configuration, add type-level overrides only where needed
4. **Addresses Core Problem**: Eliminates repetitive configuration overhead
5. **Familiar Patterns**: Combines well-known singleton pattern with Swift's attribute system

### Four-Level Precedence Hierarchy

The precedence system provides clear, predictable behavior:

1. **Method Parameters** (highest priority) - explicit developer intent
2. **Type Configuration** (`@AwaitlessConfig`) - class/struct-specific overrides  
3. **Instance Configuration** (global/module defaults) - broad application defaults
4. **Built-in Defaults** (lowest priority) - sensible fallbacks

```swift
// Example precedence resolution
AwaitlessConfig.setDefaults(prefix: "sync", delivery: .main)  // Instance level

@AwaitlessConfig(prefix: "legacy")  // Type level - overrides instance prefix
class DataService {
    @Awaitless(delivery: .background)  // Method level - overrides both instance and type delivery
    func processData() async throws -> Result {
        // Generated method uses:
        // - prefix: "legacy" (from type-level)
        // - delivery: .background (from method-level)  
        // - availability: .deprecated (from instance-level, since not overridden)
    }
}
```

### Process Isolation Strategy

**Important Note**: Using `AwaitlessConfig.setCurrent()` for process isolation has a critical flaw: it's just another global singleton per process.

**Revised Process Isolation Approach**:

Instead of a global `current` instance, process isolation should be achieved through:

1. **Build-Time Configuration Generation**: Generate configuration constants at build time
2. **Process-Scoped Configuration**: Configuration defined per application process
3. **Compile-Time Constants**: Use static properties accessible during macro expansion

```swift
// Generated at build-time or application startup
public enum AwaitlessGlobalConfig {
    public static let prefix: String? = "sync" // From AwaitlessConfig.setDefaults()
    public static let availability: AwaitlessAvailability? = .deprecated()
    public static let delivery: AwaitlessDelivery? = .main
}

// Alternative approach: MODULE_NAMEAwaitlessConfig pattern
// (Note: This approach is feasible but complex - see proof of concept)
internal enum MyAppAwaitlessConfig {
    static let prefix: String? = "sync"
    static let availability: AwaitlessAvailability? = .deprecated()
}
```

This approach provides true process isolation without global state issues.

## API Surface Design

### Configuration Data Type

```swift
public struct AwaitlessConfigData {
    public let prefix: String?
    public let availability: AwaitlessAvailability?
    public let delivery: AwaitlessDelivery?
    public let strategy: AwaitlessSynchronizationStrategy?
    
    public init(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
}
```

### Global Configuration

```swift
public enum AwaitlessConfig {
    // Global defaults (compile-time constants)
    public static func setDefaults(
        prefix: String? = nil,
        availability: AwaitlessAvailability? = nil,
        delivery: AwaitlessDelivery? = nil,
        strategy: AwaitlessSynchronizationStrategy? = nil
    )
    
    // Access current defaults (for macro expansion)
    public static var currentDefaults: AwaitlessConfigData { get }
}
```

### Type-Level Configuration Macro

```swift
@attached(member, names: named(__awaitlessConfig))
public macro AwaitlessConfig(
    prefix: String? = nil,
    availability: AwaitlessAvailability? = nil,
    delivery: AwaitlessDelivery? = nil,
    strategy: AwaitlessSynchronizationStrategy? = nil
) = #externalMacro(module: "AwaitlessKitMacros", type: "AwaitlessConfigMacro")
```

### Alternative: MODULE_NAMEAwaitlessConfig Pattern

As an alternative to the combined approach, a simpler implementation could use module-specific configuration types that macros check for automatically:

```swift
// Each module optionally defines its own configuration
internal enum NetworkingAwaitlessConfig {
    static let prefix: String? = "net"
    static let availability: AwaitlessAvailability? = .deprecated("Use async networking")
}

internal enum DataProcessingAwaitlessConfig {
    static let prefix: String? = "sync"
    static let delivery: AwaitlessDelivery? = .main
}

// Macros would generate code that checks:
// MODULE_NAMEAwaitlessConfig.prefix ?? AwaitlessConfig.currentDefaults.prefix ?? "awaitless"

// Benefits:
// ✅ No global singleton pattern needed
// ✅ True module isolation through type namespacing  
// ✅ Compile-time constants work with macro constraints
// ✅ Optional per-module setup

// Challenges:
// ⚠️ Requires Swift conditional compilation features
// ⚠️ Module name detection complexity in macros
```

This approach is **viable** and provides cleaner module separation without global state issues.

## Implementation Strategy

### Two-Phase Approach

1. **Instance Configuration Phase**: 
   - Teams set up process defaults using `AwaitlessConfig.setDefaults()`
   - Configuration is converted to compile-time constants for macro access
   - Process isolation supported through build-time configuration generation

2. **Macro Resolution Phase**:
   - Macros check for method-level parameters first
   - Then check for type-level `@AwaitlessConfig` 
   - Then access instance configuration compile-time constants
   - Finally fall back to built-in defaults

### Technical Implementation

```swift
// Generated compile-time constants from instance configuration
public enum AwaitlessGlobalConfig {
    public static let prefix: String? = "sync"  // From AwaitlessConfig.setDefaults()
    public static let availability: AwaitlessAvailability? = .deprecated()
    // ... other properties
}

// Type-level macro generates overrides
@AwaitlessConfig(prefix: "legacy")  // Generates static override properties
class DataService {
    static let __awaitlessConfig = AwaitlessConfigData(prefix: "legacy")
    
    @Awaitless  // Accesses: method params → type config → global config → defaults
    func fetchData() async throws -> Data { ... }
}
```

## Usage Examples

### Basic Global Configuration

```swift
// One-time process setup
AwaitlessConfig.setDefaults(
    prefix: "sync",
    availability: .deprecated("Use async version")
)

// Most classes need no configuration
class UserService {
    @Awaitless  // Uses global: syncFetchUser() with @available(*, deprecated)
    func fetchUser(id: String) async throws -> User { ... }
    
    @AwaitlessPublisher  // Uses global: syncStreamUserUpdates() with @available(*, deprecated)
    func streamUserUpdates() async -> AsyncStream<User> { ... }
}
```

### Type-Level Overrides

```swift
// Type-level overrides when needed
@AwaitlessConfig(prefix: "legacy")
class LegacyService {
    @Awaitless  // Uses type override: legacyProcessData() with @available(*, deprecated)
    func processData() async throws -> Result { ... }
}
```

### Method-Level Overrides

```swift
@AwaitlessConfig(prefix: "sync", delivery: .main)
class DataProcessor {
    @Awaitless  // Uses prefix="sync"
    func processData() async throws -> Result { ... }
    
    @Awaitless(prefix: "blocking")  // Override: uses prefix="blocking", keeps delivery=.main
    func heavyComputation() async throws -> BigResult { ... }
    
    @AwaitlessPublisher(deliverOn: .current)  // Override: uses deliverOn=.current, keeps prefix="sync"
    func lightweightStream() async -> AsyncStream<String> { ... }
}
```

## Comparison Matrix

| Aspect | Type-Scoped | Instance-Based | **Combined Approach** |
|--------|-------------|----------------|-----------------------|
| **User Experience** | ❌ Repetitive per-type | ✅ One-time setup | ✅ Setup once, override as needed |
| **Implementation Complexity** | ❌ Complex AST traversal | ❌ Macro limitations | ⚠️ Two-phase system |
| **Configuration Overhead** | ❌ Required per type | ✅ Optional global | ✅ Optional at all levels |

## Implementation Challenges

### Macro Limitations

Swift macros execute during compilation and have limited access to runtime state. The implementation must work within these constraints:

1. **Compile-Time Only**: Configuration must be deterministic at macro expansion time
2. **No Shared State**: Macros cannot share mutable state between invocations
3. **Limited Context**: Restricted access to AST and external information

### Solutions

1. **Generated Constants**: Convert instance configuration to compile-time constants
2. **Build-Time Integration**: Generate module-specific configuration during build
3. **Static Property Storage**: Use generated static properties for type-level configuration

## Next Steps

### Phase 1: Foundation
1. Implement `AwaitlessConfigData` and basic configuration types
2. Create global configuration system with compile-time constant generation
3. Implement `@AwaitlessConfig` macro for type-level configuration

### Phase 2: Integration
1. Update existing macros (`@Awaitless`, `@AwaitlessPublisher`, etc.) to support configuration discovery
2. Implement four-level precedence resolution
3. Add comprehensive tests for all configuration scenarios

### Phase 3: Process Isolation
1. Design and implement build-time process configuration generation
2. Create process namespace isolation system
3. Add comprehensive documentation

### Phase 4: Optimization
1. Optimize macro performance for configuration discovery
2. Add development tools for configuration debugging
3. Gather user feedback and iterate on API design

## Decision

**Adopt the Combined Approach** for AwaitlessKit configuration defaults, providing:

- **Instance-based global defaults** for broad application with minimal setup
- **Type-scoped overrides** through `@AwaitlessConfig` macro for granular control
- **Four-level precedence hierarchy** for predictable behavior
- **Process-level isolation** through build-time configuration generation

This design eliminates repetitive configuration overhead while maintaining the flexibility and precision that Swift developers expect, providing the optimal balance of user experience, implementation feasibility, and Swift idioms.
- **Related**: Swift Macros Documentation, SwiftSyntax API Reference